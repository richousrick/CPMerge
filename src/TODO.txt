TODO
	Important features
		Keep original function headers
			replace bodies with calls to merged function
		
	Clean Up code
		Remove blocks of unused code
		Annotate
		Sepperate JavaPlugin and Main Code
		replace asserts
	Test
		Test works on large Sections of code
		Test on switch
		
		
		
		
	Try out
		See if settting 
			inser/ rename = 3
			rename 0, 9
			
		
Fixes
	printing 
		? ensure always returns statement
		handle method annotations
		Better inserting/ removing of functions - check class
			change updating to create list of changes (Replacement objects)
			then iterate over them end to start replaceing 
	Parsing
		Ignore overridden functions
		Ignore inherited functions
	Logging
		log merges
	Reference updating
			Rework code to
				getFunction
					if called on object
						look at object functions
						look at extend class functions
					then scope, parent scope, ..
				Function resolution
					store composite function calls
						obj.func1().func2()
						store func1 & func 2
				
				
		

		
		
		
		
			
Limitations
	Merge Algorithm
		Implementation could be improved to auto handle variables
			create init variable type outside conditional
		
	Java Plugin
		Variables names are used
			To improve i could implement a Reference table with comparison and use that instead, allowing for different variable names to be used in the same context
	
		Merge
			nodes with differences to be grouped together and merged, must have the same parent structure
				if this wore not the case it would allow conversion of areas to functions / inner comparison
				e.g.
					f1	
						if(a == 1){
							x
					f2
						if(a == 2){
							x
					x wont match
						if it did then x could be converted into a function with call 
						or the contents could be extended into single line
							if(a == fId==1?1:2)
			Switch Case content not merged - test
			Multiple Functions that are the same name and content will break
			Does not take into account Ovveride functions
		Reference updating only works on objects parsed
			i.e. 
				if an instance of a library (l) that is not parsed uses a spacific type NewType (type)
				Where NewType had a function f1() that was merged into another function f2()
					l.type.f1() will not be changed to f2()
					but f1() will be changed to f2()
		Imports must be specific
			i.e. not in form str.*;
		if Class and interface with same name declared in same scope - large problem
			Same with two classes with same name declared
				Can have public and private type in same scope with same name
		no gernalisation support
	
Improvements For Later
	Implement Switch case merging
	Extract duplicate content from inside Functions into a new function
	implement single line conditionals for assignment / conditional head
	Improve UI
	Implement other Languages
	further multithread - each merge operation/ each class
	Copy function Annotations too
	Have a ClassNode for references- auto rename references
	Have detection only mode
	generalisation support
	Implement resoluton patterns like report
	document code
	tidy up code
		clean up dead code
		rename functions / vaiables to be more descriptive
		
		
Subset of Java
	No Generics
	No Overrided functions
	Only consider whole line